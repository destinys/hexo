---
title: Java编程自学之路：泛型类型
categories: Program
tags: java
date: 2021-08-03
author: Semon
---

# Java泛型类型

JDK5引入了泛型的概念，泛型的出现，解决了类型安全问题；

泛型具有以下优点：

+ 编译时强类型检查

  泛型要求在声明时指定实际数据类型，Java编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警；早发现早治理；编译器发现并修复错误代价远低于运行时；

+ 避免类型转换

+ 泛型编程可以实现通用算法；

## 泛型使用

### 泛型类

泛型类声明语法：

```java
class  clazzName<T1, T2, ... ,Tn>  {  /*...*/ }
```

泛型类的声明与非泛型类的声明类似，除了在类名后添加类型参数声明部分；类型参数部分声明使用`<>`包围，位于类名与类语句块之间；

一般将泛型中的类名称为**原型**，将`<>`指定的参数称为**类型参数**；

### 泛型接口

接口也可以声明泛型；

泛型接口声明语法：

```java
public interface InterName <T> { 
	public T demo() { /* ... */ };
}
```

泛型接口有两种实现方式：

+ 实现接口时明确泛型类型
+ 实现接口时继承泛型类型

```java
// m1:实现接口时明确泛型类型
public class GenericsDemo01 implements InterName<Integer> {
	@Override
  public Integer demo()  {  /* ... */ };
}

//m2 ：实现接口时继承泛型类型
public class GenericsDemo02<T> implements InterName<T> {
  @Override
  public T demo() { /* ... */ };
} 
```

### 泛型方法

泛型方法是引入自己声明的泛型参数的方法，泛型方法可以是普通方法、静态方法或构造方法；

泛型方法声明语法：

```java
public <T> T func(T obj)  { /*...*/};
```

泛型方法通过`<>`来生命泛型类型，出现在方法返回类型之前，泛型类型可以被用来作为方法返回值类型，也可以来定义方法的参数列表（也支持变长参数列表）；

泛型方法调用时通常不比执行类型参数，因为编译器会为我们找出具体的类型，这种行为称为**类型参数推断**；类型推断仅对赋值操作有效；

> 如果将泛型方法调用的结果作为参数传递给另一个方法，编译器会将泛型返回结果赋值给一个`Object`类型的变量，再传递给另一个方法；

## 泛型特性

### 类型擦除

Java语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程，不同于C++的模板机制，Java泛型是使用类型擦除来实现的，即泛型在运行期间，任何具体的类型信息都被擦除了； 

类型擦除流程：

1. 将泛型中所有类型的参数统一替换为`Object`，如果指定类型边界，则使用类型边界来替换；因此，生成的字节码仅包含普通的类、接口和方法；
2. 擦除出现的类型生命，即去掉`<>`的内容，比如`T get()`方法声明退化成了`Object get()`；
3. 生成桥接方法以保留扩展反省类型中的多态性；类型擦除确保不为参数化类型创建新类；因此，泛型不会额外产生运行时开销；

> Java泛型的实现方式不够优雅，这是因为引入时需要兼容老版本代码，必须在设计上做的一些妥协；

### 泛型继承

泛型是基于类型擦除实现的，所以泛型类型无法向上转型；

> 向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要提现；

## 泛型边界与约束

### 泛型边界

在特定场景中，程序员可能希望限制可在泛型类型中用作类型参数的范围；类型边界可以对泛型的类型参数设置限制条件；

要声明有界类型参数，需列出类型参数的名称、限制关键字`extends`，后接其限制类或接口；

类型边界的语法为：

```java
<T extends T1 [& T2]>
```

+ T1为类或接口；
+ T2只能为接口；

### 类型通配符

Java中一般使用`？`来代替具体的类型参数；

#### 上界通配符

上界通配符来缩小类型参数的类型范围；

语法形式为：`<? extends Number>`；

#### 下界通配符

下界通配符用来将未知类型限制为该类型的特定类型或超类类型；

语法形式为：`<？ super Number>`

> 注意：上界通配符与下界通配符不能同时使用；

#### 无界通配符

泛型继承中提到过泛型是不能向上转型的，但是我们可以通过使用通配符来变相实现向上转型；

### 泛型约束

泛型类型的类型参数不能是值类型；

泛型类型不能创建类型参数的实例；

泛型类型不能声明类型参数的静态成员；

泛型类型的类型参数不能使用类型转换或`instanceof`；

泛型类型不能创建类型参数的数组；

泛型类型不能创建、`catch`或`throw`参数化类型对象；

泛型类型相同但类型参数不同的方法不能重载；

## 泛型最佳实践

### 泛型命名

泛型有一些约定俗成的命名：

+ `E`:`Element`
+ `K`：`Key`
+ `N`:`Number`
+ `T`：`Type`
+ `V`：`Value`

### 泛型使用建议

+ 消除类型检查告警；
+ `List`优先数组；
+ 优先考虑使用泛型来提高代码通用性；
+ 优先考虑使用泛型方法来限定泛型范围；
+ 利用通配符来提升API灵活性；
+ 优先考虑类型安全的异构容器；
