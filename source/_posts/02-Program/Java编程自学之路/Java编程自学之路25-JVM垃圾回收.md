---
title: Java编程自学之路：JVM垃圾回收
categories: Program
tags: java
date: 2021-08-03
author: Semon
---

# JVM垃圾收集

程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有，只存在于线程的生命周期，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收的主要对象是Java堆和方法区。

## 对象活着吗

### 引用计数算法

给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数为0的对象可被回收。

两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。

因为循环引用的存在，所以Java虚拟机不适用引用计数算法。

### 可达性分析算法

通过`GC Roots`作为七点进行搜索，`JVM`将能够到达的对象是为存活，不可达的对象视为死亡。

<img src="./Java编程自学之路25-JVM垃圾回收/image-20210728005638987.png" alt="可达性分析算法" style="zoom:80%;" />

可作为`GC Roots`的对象包括以下几种：

+ 虚拟机栈中引用的对象；
+ 本地方法栈中引用的对象（`Native`方法）；
+ 方法区中，类静态属性引用的对象；
+ 方法区中，常量引用的对象；

### 引用类型

无论通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否可被回收都与引用有关。

Java具有四种强度不同的引用类型。

**强引用**

被强引用关联的对象不会被垃圾回收器回收。

强引用：使用`new`一个新对象的方式来创建强引用。

**软引用**

被软引用关联的对象，只有在内存不够的情况下才会被回收。

软引用：使用`SoftReference`类来创建软引用。

**弱引用**

被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。

使用`WeakReference`类来实现弱引用。

**虚引用**

又被称为幽灵引用或者幻影引用。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用取的一个对象实例。

为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

使用`PhantomReference`来实现虚引用。

### 方法区回收

因为方法区主要存放永久代对象，而永久代对象的回收率比年轻代差很多，因此在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载。

类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

+ 该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例；
+ 加载该类的`ClassLoader`已经被回收；
+ 该类的`java.lang.Class`对象没有在任何地方被引用，也就无法在任何地方通过反射方位该类方法；

可以通过`-Xnoclassgc`参数来控制是否对类进行卸载。

在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义`ClassLoader`的场景跟你都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。

### finalize()

`finalize()`类似C++的析构函数，用来做关闭外部资源等工作。但是`try-finally`等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用`finalize()`。

当一个对象可被回收时，如果需要执行该对象的`finalize()`方法，那么就可能通过在该方法中让对象重新被引用，从而实现自救。

## 垃圾回收算法

### 垃圾收集性能

垃圾收集器的性能指标有两点：

+ 停顿时间：停顿时间是因为GC而导致程序不能工作的时间长度；
+ 吞吐量：吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内；

### 标记-清除

<img src="./Java编程自学之路25-JVM垃圾回收/image-20210728011618987.png" alt="Mark-Sweep算法" style="zoom:80%;" />

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

这种做法嫩巩固解决内存碎片化的问题，但代价是压缩算法的性能开销。

### 复制

<img src="./Java编程自学之路25-JVM垃圾回收/image-20210728011755687.png" alt="Copy算法" style="zoom:80%;" />

将内存划分为大小相等的两块，每次只使用其中一块，当这一块用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法来回收年轻代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的`Eden`空间和两块较小的`Survivor`空间，每次使用`Eden`空间和其中一块`Survivor`。在回收时，将`Eden`和`Survivor`中还存活的对象复制到另一块`Survivor`空间上，最后清理`Eden`和使用过的`Survivor`。`Hotspot`虚拟机的`Eden`和`Survivor`的大小比例默认为8:1（可以通过参数`-XX:SurvivorRatio`来调整比例），保证了内存的利用率到90%。如果每次回收有多余10%的对象存活，那么一块`Survivor`空间就不够了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

### 分代收集

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将Java堆分为年轻代和老年代。

+ 年轻代：使用复制算法；
+ 老年代：使用标记-清理算法或标记-整理算法；

<img src="./Java编程自学之路25-JVM垃圾回收/image-20210728012723739.png" alt="Hotspot Heap Structure" style="zoom:80%;" />

**新生代**

新生代是大部分对象创建和销毁的区域，在通常的Java应用中，绝大部分对象生命周期都是很短暂的。其内部又分为`Eden`区域，作为对象初始分配的区域；两个`Survivor`，有时候也叫`from`、`to`区域，被用来放置从`Minor GC`中保留下来的对象。

JVM会随意选取一个`Survivor`作为`to`，然后在GC过程中进行区域间拷贝，也就是将`Eden`中存活下来的对象和`from`区域的对象，拷贝到`to`区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。

Java虚拟机会记录`Survivor`区中的对象一共被来回复制了几次。如果一个对象被复制的次数为15（对应虚拟机参数`-XX:+MaxTenuringThreshold`），那么该对象将被晋升（`promote`）至老年代。另外，如果单个`Survivor`区已经被占用了50%（对应虚拟机参数`-XX:TargetSurvivorRatio`），那么较高复制次数的对象也会被晋升至老年代。

**老年代**

防止长生命周期的对象，通常都是从`Survivor`区域拷贝过来的对象。当然，也有特殊情况，如果对象较大，JVM会试图直接分配在`Eden`其它位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。

**永久代**

这部分就是早期`Hotspot` JVM的方法区实现方式，储存Java类元数据、常量池、`Intern`字符串缓存。JDK8之后改为存储在元数据空间中。

### JVM参数

jvm允许对堆空间大小、各代空间大小进行设置，以调整JVM GC。

| 配置                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| `-Xss`              | 虚拟机栈大小                                                 |
| `-Xms`              | 堆空间初始值                                                 |
| `-Xmx`              | 堆空间最大值                                                 |
| `-Xmn`              | 新生代空间大小                                               |
| `-XX:NewSize`       | 新生代空间初始值                                             |
| `-XX:MaxNewSize`    | 新生代空间最大值                                             |
| `-XX:NewRatio`      | 新生代与老年代比例，默认为2，意味着老年代是新生代的2倍       |
| `-XX:SurvivorRatio` | 新生代中调整`Eden`与`Survivor`的比例，默认为8.即`eden`区为80%的大小，两个`Survivor`分别为10%大小 |
| `-XX:PermSize`      | 永久代空间的初始值                                           |
| `-XX:MaxPermSize`   | 永久代空间最大值                                             |

## 垃圾收集器

<img src="Java编程自学之路25-JVM垃圾回收/image-20210728014629695-8082265.png" alt="GC" style="zoom:80%;" />

以上为`Hotspot`虚拟机中的7个垃圾收集器，连线表示垃圾回收器可以配合使用。

> G1垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。

### 串行收集器

串行收集器（`Serial`）是最基本、发展历史最悠久的收集器。

串行收集器是`client`模式下的默认收集器配置。因为在客户端模式下，分配给虚拟机管理的内存一般来说不会很大。`Serial`收集器收集几十兆甚至一两百兆的年轻代停顿时间可以控制在一百毫秒以内，只要不是太频繁，这点停顿是可以接受的。

串行收集器采用单线程`stop-the-world`的方式进行收集。当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点（`Safepoint`）时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。

单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核CPU的场合。

> 开启选项：`-XX:UseSerialGC`
>
> 打开此开关后，使用`Serial + SerialOld`收集器组合来进行内存回收。

**Serial Old收集器**

`Serial Old`是`Serial`收集器的老年代版本，也是给`Client`模式下的虚拟机使用。如果用在`Server`模式下，它有两大用途：

+ 在JDK1.5之前版本中与`Parallel Scavenge`收集器搭配使用；
+ 作为`CMS`收集器的后备预案，在并发收集发生`Concurrent Modle Failure`时使用；

### 并行收集器

其他收集器都是以关注停顿时间为目标，而并行收集器是以关注吞吐量为目标的垃圾收集器。

+ 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；
+ 高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

```
吞吐量 = 运行用户代码时间 /(运行用户代码时间 + 垃圾手机时间)
```

并行收集器是`server`模式下的默认收集器。

并行收集器与串行收集器工作模式相似，都是`stop-the-world`方式，只是暂停时并行地进行垃圾收集。并行收集器年轻代采用复制算法，老年代采用标记-整理，再回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。

在注重吞吐量以及CPU资源敏感的场景，都可以优先考虑`Parallel Scavenge`收集器 + `Parallel Pld`收集器。

**Parallel Scavenge收集器**

`Parallel Scavenge`收集器提供了两个参数用于精确控制吞吐量，分别是：

+ `-XX:MaxGCPauseMillis`：控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值；
+ `-XX:GCTimeRatio`：直接设置吞吐量代销（值为大于0且小于100的整数）；

缩短停顿时间是以牺牲吞吐量和年轻代空间来换取的：年轻代空间变小，垃圾回收变的频繁，导致吞吐量下降；

`Parallel Scavenge`收集器还提供了一个参数`-XX:+UseAdptiveSizePolicy`，这是一个开关参数，打开参数后，就不需要手工指定年轻代大小、`Eden`和`Survivor`比例、进程老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况手机性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为GC自适应调节策略。

**Parallel Old收集器**

是`Parallel Scavenge`收集器的老年代版本，使用多线程和“标记-整理”算法。

### 并发标记清除收集器

并发标记清除收集器是以获取最短停顿时间为目标。

开启后，年轻代使用`ParNew`收集器；老年代使用`CMS`收集器，如果CMS产生的碎片过多，导致无法存放浮动垃圾，JVM或出现`Concurrent Mode Failure`，此时使用`Serial Old`收集器来替代`CMS`收集器清理碎片。

> 开启选项：`-XX:UseConcMarkSweepGC`
>
> 开启后，虚拟机将使用`CMS + ParNew + Serial Old`收集器组合来进行内存回收；

#### CMS收集器

`CMS`收集器是一种以获取最短停顿时间为 目标的收集器。

`CMS（Concurrent Mark Sweep）`，`Mark Sweep`指的是标记-清除算法。

`CMS`收集器运行步骤如下：

1. 初始标记：仅仅只是标记以下`GC Roots`能直接关联到的对象，速度很快，但也需要停顿；
2. 并发标记：进行`GC Roots Tracing`的过程，它在整个回收过程中耗时最长，不需要停顿；
3. 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要停顿；
4. 并发清楚：回收在标记阶段被鉴定为不可达的对象；不需要停顿；

**CMS回收年轻代**

+ 堆空间被分割为三块空间

  年轻代分割成一个`Eden`区和两个`Survivor`区。老年代是一个连续的空间。

+ CMS年轻代垃圾收集

  使用`CMS`，老年代对象就地释放，它们不会被来回移动；这个空间不会被压缩除非发生`FullGC`。

+ 年轻代收集

  从`Eden`和`Survivor`区复制活跃对象到另一个`Survivor`区。所有到达年龄阈值的对象会晋升到老年代。

+ 年轻代回收

  一次年轻代垃圾收集之后，`Eden`区和`Survivor`区被清空。

**CMS回收老年代**

+ CMS老年代收集

  发生两次`stop the world`事件：初始标记和重新标记，`CMS`开始执行。

  + 初始标记是一个短暂暂停的、可达对象被标记的阶段；
  + 并发标记需要活跃对象在应用连续执行时；
  + 重新标记阶段，寻找在之前并发标记阶段中丢失的对象；

+ 老年代收集-并发清除

  在之前阶段没有被标记的对象会被就地释放，不进行压缩操作。

  未被标记的对象等于死亡对象。

+ 老年代收集-清除之后

  清除阶段之后，会有大量内存被释放，且不进行压缩。CMS收集器会再次进入重新设置阶段，等待下一次垃圾收集时机到来。

**CMS特点**

`CMS`收集器有以下缺点：

+ 并发收集：并发指定是用户线程和GC线程同时运行；
+ 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不够高；
+ 无法处理浮动垃圾：可能出现`Concurrent Mode Failure`异常；浮动垃圾是指并发清楚阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着CMS收集不能像其它收集器那样等待老年代快满的时候在回收；
  + 可以使用`-XX:CMSInitiatingOccupancyFraction`改变触发`CMS`收集器工作的内存占用百分比，如果这个值设置过大，导致预留内存不够存放浮动垃圾，就会出现`Concurrent Mode Failure`，此时虚拟机将临时启用`Serial Old`收集器来替代CMS收集器；
+ 标记：清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续堆空间来分配当前对象，不得不提前出发`FullGC`；
  + 可以使用`-XX:+UseCMSCompactAtFullCollection`，用于在`CMS`收集器要进行`FullGC`时开启内存碎片的合并整理，内存整理的过程是无法并发的，内存碎片问题没有了，但停顿时间将不得不延长；
  + 可以是使用`-XX:+UseCMSFullGCsBeforeCompaction`，设置执行了多少次不压缩的`FullGC`后，进行一次带压缩的（默认为0，表示每次进入`FullGC`时都进行压缩）；

##### ParNew收集器

`ParNew`收集器其实是`Serial`收集器的多线程版本。

> 开启选项：`-XX:UseParNewGC`

`ParNew`是`Server`模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了`Serial`收集器，只有`ParNew`能够与`CMS`收集器配合工作。

`ParNew`收集器默认开启的线程数与CPU数量相同，可以使用`-XX:ParallelGCThreads`参数来设置线程数。

### G1收集器

`G1`收集器是一种兼顾吞吐量和停顿时间的GC收集器。`G1`是`Oracle JDK9`以后默认的收集器。`G1`可以直观的设定停顿时间的目标，相比于`CMS GC`，`G1`未必能做到`CMS`在最好情况下的延时停顿，但是最差情况要好很多。

`G1`最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至`CMS`的众多缺陷。

#### 分区和分代

旧的垃圾收集器一般采集分代收集，Java对被分为年轻代、老年代和永久代。收集的范围是整个年轻代或老年代。

`G1`取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（`Region`），年轻代和老年代不在物理隔离。`G1`可以直接对年轻代和老年代一起回收。

通过引入`Region`概念，将原来的一整块内存空间划分为多个小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，是的可预测的停顿时间模型成为可能。通过记录每个`Region`垃圾回收时间以及回收所获得的空间（根据历史经验值推断），并维护一个优先列表，每次根据允许的手机时间，优先回收价值最大的`Region`。

每一个`Region`都有一个`Remembered Set`，用来记录该`Region`对象的引用对象所在的`Region`。通过使用`Remembered Set`，在做可达性分析的时候可以避免全堆扫描。

#### 运作流程

忽略`Remembered Set`维护操作，大致流程如下：

1. 初始标记
2. 并发标记
3. 最终标记：为了修正并发标记期间因用户程序继续运行导致标记发生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的`Remembered Set Logs`里面，最终标记阶段需要把`Remembered Set Logs`的数据合并到`Remembered Set`中。这个阶段需要停顿线程，但是可并行执行；
4. 筛选回收：首先对各个`Region`中的回收价值和成本进行排序，根据用户所期望的`GC`停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分`Region`，时间是用户可控的，而且停顿用户线程将大幅度提高收集效率；

**特点：**

+ 空间整合：整体来看是基于“标记-整理”算法实现的收集器。从局部（`Region`）来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片；
+ 可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒；

**G1回收年轻代**

+ G1初始堆空间

  堆空间是一个被分成许多固定大小区域的内存块。

+ G1堆空间分配

  实际上，G1堆空间被映射成`Eden`、`Survivor`、老年代空间的逻辑表达形式。活跃对象从一个`Region`疏散（复制、移动）到另一个`Region`。`Region`被设计为并行的方式收集，可以暂停或不暂停所有的其他用户线程。

  堆内存除了被分配成`Eden`、`Survivor`及`Old`区域外，还有第四种类型的区域：极大区域（`Humongous regions`）。这些区域被设计成保持标准区域大小的50%或者更大对象。他们被保存在一个连续的区域集合里。最后一个类型的区域就是堆空间里没有使用的区域。

+ G1的年轻代

  堆空间被分割成大约2000个区域（`Region`）。最小1M，最大32M，区分不同的`Region`用来单独保存年轻代对象或老年代对象。

+ G1年轻代收集

  活跃对象被疏散到一个或多个`Survivor`区域。如果达到晋升年龄阈值，对象会晋升到老年代区域。这是一个`stop the world`暂停，为下一次年轻代垃圾回收计算`Eden`和`Survivor`的大小，保留审计信息有助于计算大小。类似目标暂停时间会被考虑在内。这个方法使重调区域大小变得容易，可以按需调整`Region`大小。

+ G1年轻代回收

  活跃对象被疏散到`Survivor`或者老年代区域。

  关于G1年轻代回收：

  + 堆空间是一块单独的内存空间被分割成多个区域；
  + 年轻代内存是由一组非连续的区域组成。这使得需要重调大小变得容易；
  + 年轻代垃圾回收是`stop the world`事件，所有线程都会因此操作暂停；
  + 年轻代垃圾收集使用多线程并行回收；
  + 活跃对象被复制到新的`Survivor`区或老年代区域；

**G1回收老年代**

+ 初始标记阶段

  年轻代垃圾收集肩负活跃对象初始标记的任务。在日志文件中被标为`GC pause (young)`。

+ 并发标记阶段

  发现空白区域，在重新标记阶段会被马上清除掉。决定火星的审计信息也在此时被计算。

+ 重新标记阶段

  空的区域被清楚和回收掉。所有区域的活性在此时计算。

+ 复制/清理阶段

  G1选择活性最低的区域，这些区域能够以最快的速度回收。这些区域会在年轻代垃圾回收过程中被回收（日志中记录为`GC pause(mixed)`）所有年轻代与老年代是在同一时间被回收的。

+ 复制/清理阶段

  被选择的区域将被回收或压缩存储到其他`Region`。

### 收集器总结

| 收集器              | 串行/并行/并发 | 年轻代/老年代 | 收集算法       | 目标     | 适用场景                           |
| ------------------- | -------------- | ------------- | -------------- | -------- | ---------------------------------- |
| `Serial`            | 串行           | 年轻代        | 复制           | 速度优先 | 单CPU环境Client模式                |
| `Serial Old`        | 串行           | 老年代        | 标记-整理      | 速度优先 | 单CPU环境下Client模式、CMS后备预案 |
| `ParNew`            | 串行+并行      | 年轻代        | 复制           | 速度优先 | 多CPU环境Server模式与CMS配合       |
| `Parallel Scavenge` | 串行+并行      | 年轻代        | 复制           | 吞吐优先 | 后台运算少交互场景                 |
| `Parallel Old`      | 串行+并行      | 老年代        | 标记-整理      | 吞吐优先 | 后台运算少交互场景                 |
| `CMS`               | 串行+并行      | 老年代        | 标记-清除      | 速度优先 | B/S系统服务端应用                  |
| `G1`                | 串行+并行      | 年轻代+老年代 | 标记-整理+复制 | 速度优先 | 面向服务端应用，CMS替代方案        |

## 内存分配回收策略

对象的内存分配，也就是在堆上分配。主要分配在年轻代的`Eden`区上，少数情况下也可能直接分配在老年代中。

### Minor GC

当`Eden`区空间不足时，会触发`Minor GC`。

`Minor GC`发生在年轻代上，因为年轻代对象存活时间很短，因此`Minor GC`会频繁执行，执行的速度一般会比较快。

`Minor GC`工作流程：

1. Java应用不断创建对象，通常都是分配在`Eden`区域，当其空间不足时（达到设定的阈值），触发`Minor GC`。仍然内引用的对象存活下来，被复制到JVM选择的`Survivor`区域，而没有被引用的对象则被回收；
2. 经过一次`Minor GC`，`Eden`区就会空闲下来，直到再次达到`Minor GC`触发条件。这时候，另外一个`Survivor`区域则会成为`To`区域。`Eden`区域的存活对象和`From`区域对象，都会被复制到`To`区域，并且存活的年龄计数加1；
3. 重复步骤2，知道有对象年龄计数达到阈值，这时候就会发生晋升（`Promotion`）过程，超过阈值的对象会被晋升到老年代。

### Full GC

`Full GC`发生在老年代上，老年代对象和年轻代相反，其存活时间长，因此`Full GC`很少执行，而且执行速度会比`Minor GC`慢很多。

**内存分配策略**

+ 对象优先在`Eden`分配

  大多数情况下，对象在年轻代`Eden`区分配，当`Eden`区空间不足时，发起`Minor GC`.

+ 大对象直接进入老年代

  大对象是指需要连续内存空间的对象，最典型的大对象如长字符串及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

  参数`-XX:PretenureSizeThreshold`配置大于该值的对象直接在老年代分配，避免`Eden`区和`Survivor`区之前的大量内存复制。

+ 长期存活对象进入老年代

  为对象添加年龄计数器，对象在`Eden`出生并经过`Minor GC`仍然存活，将移动到`Survivor`中，年龄计数器加1，增加到年龄阈值则移动到老年代中。年龄阈值可通过参数`-XX:MaxTenuringThreshold`配置。

+ 动态对象年龄判断

  JVM并不是永远地要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升老年代，如果在`Survivor`区中相同年龄虽有对象大小的综合大于`Survivor`空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到`MaxTenuringThreshold`要求的年龄。

+ 空间分配担保

  在发生`Minor GC`之前，JVM先检查老年代最大可用的连续空间是否大于年轻代所有对象空间总和，如果条件成立，则`Minor GC`可以确认是安全的；如果不成立JVM或查看`HandlePromotionFailure`设置值是否允许担保失败，如果允许那么就会继续检查老年代可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次`Minor GC`，尽管这次`Minor GC`是有风险的；如果小于，或者`HandlePromotionFailure`设置不允许冒险，那这时也要改为进行一次`Full GC`。

**Full GC触发条件**

对于`Minor GC`，其触发条件非常简单，当`Eden`区空间满时，便会触发；而`Full GC`则相对复杂，有以下条件：

+ 调用`System.gc()`

  显示调用该方法是建议虚拟机进行`Full GC`，虽然只是建议而非一定，但很多情况下它会触发`Full GC`，从而增加`Full GC`的频率，也即增加了间歇性停顿的次数。因此强烈不建议显式调用此方法，而是让JVM自己去管理它的内存。可通过`-XX:DisplayExplicitGC`来禁止`RMI`调用`System.gc()`。

+ 老年代空间不足

  老年代空间不足的常见场景有：大对象直接进入老年代、长期存活对象进入老年代等，当执行`Full GC`后空间仍然不足，则抛出`java.lang.OutOfMemoryError:Java heap space`。为避免以上原因引起`Full GC`，调优时应尽量做到让对象在`Minor GC`阶段被回收、让对象在年轻代多存活一段时间以及不要创建过大的对象及数组。

+ 方法区空间不足

  JVM规范中运行时数据区域中的方法区，在`Hotspot`虚拟机中又被习惯称为永久代，永久代中存放的是类的描述信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用`CMS GC`的情况下也会执行`Full GC`。如果`Full GC`仍然回收不了，那么JVM将抛出`java.lang.OutOfMemoryError:PermGen space`错误。为避免永久代占满造成`Full GC`现象，可采用的方法为增大`Perm Gen`空间或转为使用`CMS GC`.

+ `Minor GC`平均晋升空间大于老年代剩余空间

  统计数据显示`Minor GC`的平均晋升空间比老年代剩余空间大，则不会触发`Minor GC`而是转为触发`Full GC`。

+ 对象大于`To`区和老年代可用内存

  由`Eden`区、`From`区向`To`区复制时，对象大于`To`区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。
