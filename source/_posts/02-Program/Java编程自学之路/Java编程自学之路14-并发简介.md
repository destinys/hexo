---
title: Java编程自学之路：并发简介
categories: Program
tags: java
date: 2021-08-03
author: Semon
---

# 并发概念

并发编程中有很多术语概念相近，容易混淆。

## 并发和并行

并发和并行最关键的差异在于：是否同时发生。

+ 并发：指具备处理多个任务的能力，但不一定要求同时。
+ 并行：指具备同时处理多个任务的能力。

> 要求以下几个人画一个圆形和一个方形：
>
> + 杨过：因为只有一只手，只能先画一个圆形，然后再画一个方形。— **既不支持并行也不支持并发**
> + 黄蓉：可以左手先画个圆形，然后右手画个方形，但无法两只手同时完成画圆形和方形。 — **支持并发但不支持并行**
> + 小龙女：精通左右互搏术，可以同时左手画圆形，右手画方形。 — **支持并行**

## 同步与异步（线程间调用）

同步与异步表示的是一种**协作方式**，从全局角度看待进程之间的关系，关注的是消息通信机制。

+ 同步：调用者需要等待被调用者返回结果，才进行下一步操作；
+ 异步：调用者发起调用后不需要等待被调用者返回结果，直接进行其他操作；被调用者依靠事件、回调机制等来通知调用者结果；

## 阻塞与非阻塞（线程内调用）

阻塞与非阻塞描述的是**线程状态**，在某个时刻，线程要么处于阻塞，要么处于非阻塞；

阻塞：指调用结果返回之前，线程被挂起；

非阻塞：指调用不能立刻得到结果时，当前线程继续进行其他操作；

> 阻塞是实现同步的一种手段；

## 举例说明

1. 同步阻塞：小明家里穷，洗衣机不是自动化的，衣服洗好了也不会发出提示，而且人还笨；衣服放进洗衣机后，一直在旁边看洗衣机知道衣服洗完；
2. 异步阻塞：经过辛苦挣钱，买了一台高级洗衣机，衣服洗好之后会响铃通知；衣服放进洗衣机后，一直在洗衣机旁边等待洗衣机洗完衣服响铃；
3. 同步非阻塞：某天高级洗衣机坏掉了，只好临时再用下原来的洗衣机，但经过这么长时间使用洗衣机，总结了一些经验，在把衣服放到洗衣机开始洗之后，就回去做家务，隔一段时间回来看下洗衣机是否洗完衣服，循环往复直到衣服洗完；
4. 异步非阻塞：高级洗衣机修好之后，经过经验总结，发现可以把衣服放到洗衣机启动后，可以放心的去做家务，等到洗衣机响铃后，过来晾衣服就可以了。

> 小明看洗衣机状态是否洗完，是为同步；
>
> 洗衣机响铃通知小明衣服是否洗完，是为异步；
>
> 小明将衣服放到洗衣机后，一直蹲在洗衣机旁等待衣服洗完，是为阻塞；
>
> 小明将衣服放到洗衣机后，就去做家务，是为非阻塞；

## 进程与线程

+ 进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。进程可视为一个正在运行的程序。
+ 线程：线程是操作系统进行调度的基本单位；

> 1. 进程是操作系统分配资源的最小单位，线程是程序执行的最小单位
>
> 2. 一个进程由一个或多个线程组成。
> 3. 进程间相互独立，同一进程下的线程之间共享内存空间。

## 竞态条件与临界区

+ 竞态条件：`Race Condition`，当两个线程竞争同一资源时，如果对资源的访问顺序敏感，则称存在竞态条件。
+ 临界区：`Critical Sections`，导致竞态条件发生的代码区称为临界区。

## 管程

管程(`Monitor`)，指管理共享变量以及对共享变量的操作过程，让他们支持并发。

Java采用的是管程技术，`synchronized`关键字以及`wait()`、`notify()`、`notifyAll()`这三个方法都是管程的组成部分。而管程和信号量是等价的，即可以用管程实现信号量，也可以用信号量实现管程。

# 并发的特点

技术在进步，CPU、内存、IO设备的性能也在不断提高。但是，始终存在一个核心矛盾：CPU、内存、IO设备存在速度差异。CPU远快于内存，内存远快于IO设备。

木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块模板。同理，计算机整体性能取悦于最慢的操作，即IO操作，所以单独提高CPU或者内存性能效果基本可以忽略。

<img src="./Java编程自学之路14-并发简介/image-20210715170322359.png" alt="木桶短板理论" style="zoom:80%;" />

为了合理利用CPU的高性能，平衡三者之间的速度差异，计算机体系结构、操作系统】编译程序都做出了贡献，主要体现在：

+ CPU增加缓存，以均衡与内存的速度差异
+ 操作系统增加进程与线程，以分时复用CPU，进而均衡CPU与IO设备的速度差异
+ 编译程序优化指令执行次序，使缓存能够得到更加合理的利用

## 并发的问题

任何事务都有两面性，并发也不例外。

优点：

+ 提升资源利用率
+ 提升程序响应速度

缺点：

+ 安全性问题
+ 活跃性问题
+ 性能问题

# 安全性问题

并发最重要的问题就是并发安全问题。

并发安全问题是指保证程序的正确性，使得并发处理结果符合预期。

并发安全需要保证以下几个基本特征：

+ 可见性：一个线程修改了某个共享变量后，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，`volatile`就是负责保证可见性的。
+ 原子性：相关操作不会中途被其他线程干扰，一般通过同步机制实现。
+ 有序性：保证线程内串行语义，避免指令重排。

## 保证安全策略

+ 阻塞同步

  又叫互斥同步，是最常见的并发安全保障手段。通过同步保证多线程并发访问共享数据是，同一时刻只会被一个线程访问。

  临界区、互斥量和信号量是主要的互斥实现方式，典型的案例是使用`synchronized`或`Lock`。

  互斥同步中线程阻塞和唤醒会带来性能问题。互斥同步属于一种悲观并发策略，它认为只要不做正确的同步措施，就肯定会出现问题。

+ 非阻塞同步

  非阻塞同步采用基于冲突检测的乐观并发策略：先进行操作，如果没有其他线程竞争则成功，否则采取补偿措施（不断重试直至成功）。非阻塞同步需要硬件指令集支持，因为操作和冲突检测的原子性需要硬件来保证。

  Java典型应用场景为：J.U.C包中的原子类(基于`Unsafe`类的CAS操作)

+ 无同步

  同步的目的是为了保证共享数据争用时的正确性，如果方法调用不涉及共享数据则不需要同步。

  Java中的无同步方案有：

  + 可重入代码：也叫纯代码。如果一个方法的返回结果是可预测的，即输入数据确定则返回结果确定，那它就满足可重入性，当然也就是线程安全的。
  + 线程本地存储：使用`ThreadLocal`为共享变量在每个线程中都创建一个本地副本，这个副本只能被当前线程访问，其他线程无法访问，那么线程也是安全的。

# 活跃性问题

## 死锁（Deadlock）

**什么是死锁？**

多个线程互相等待对象释放锁的情况叫做死锁。

**如何避免死锁？**

1. 按序加锁

   当多个线程需要相同的锁时，如果按照不同的顺序加锁，则很容易发生死锁。

   按照顺序加锁是一种有效的死锁预防机制。

2. 超时释放锁

   对锁配置一个超时时间是一个比较好的避免死锁的方法。

3. 死锁检测

   死锁检测是一个更好的死锁预防机制，，它主要针对不可能实现按序加锁且无法配置超时释放锁场景。

   死锁检测成功后，有两种处理手段：

   + 释放所有锁：释放所有锁后，回退，等待一段随机时间后重试。但如果有大量线程竞争同一批锁，还是会重复触发死锁，无法从根本上解决竞争。
   + 线程优先级：通过设置优先级，在发生死锁时，让部分线程回退规避竞争。

## 活锁（Livelock）

**什么是活锁？**

活锁是一个递归场景，两个或更多的线程不断重复一个特定的代码逻辑。

**如何避免活锁？**

解决活锁的方案很简单，线程间避让时，尝试添加一个随机的等待时间即可。

## 饥饿（Starvation）

**什么是饥饿？**

+ 高优先级线程占用所有低优先级线程的CPU时间
+ 线程被永久堵塞在一个等待进入同步块的状态
+ 线程等待一个本身处于永久等待完成的对象

**如何解决饥饿？**

Java不可能实现100%的公平性，但我们可以通过同步结构在线程间提升公平性。具体有以下方案：

+ 保证资源充足
+ 尽可能公平分配资源
+ 避免持有锁的线程长时间执行

> 三个方案中，方案1和方案3适用场景有限。方案2适用场景相对较广。
>
> 在并发编程中，主要通过公平锁来实现公平分配资源。所谓公平锁，是一种先来后到的方案。根据线程等待顺序按序分配资源。

# 性能问题

并发执行一定比串行执行快吗？线程越多执行就越快吗？

其实，并发并不一定总是比串行快，因为创建线程和线程上下文切换会产生性能开销。

## 上下文切换

**什么是上下文切换？**

当CPU从执行一个线程切换到另一个线程时，CPU需要保存当前线程的本地数据、程序指针等状态，并加载下一个要执行的线程的本地数据、程序指针等。这个开关就被称为“上下文切换”。

**减少上下文切换方法**

+ 无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照哈希算法分区，不同线程处理不同分区的的数据。
+ CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
+ 使用最少线程：避免创建不需要的线程。
+ 使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

## 资源限制

**什么是资源限制？**

资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。

**资源限制引发的问题**

在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分编程并行执行，但如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。

**如何解决资源限制的问题**

在资源限制情况下进行并发编程，根据不同的资源限制调整程序的并发度。

+ 对于硬件资源限制，可以考虑使用集群并行执行程序。
+ 对于软件资源限制，可以考虑使用资源池进行资源复用。

# 小结

并发编程可以总结为三个核心问题：分工、同步、互斥。

+ 分工：指如何高效地拆解任务并分配给线程
+ 同步：指线程之间如何协作
+ 互斥：指保证同一时刻只允许有一个线程访问共享资源



