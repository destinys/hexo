---
title: TCP连接的“三次握手”与“四次挥手”
categories: 网络
tags: tcp
author: semon
date: 2021-08-09
---

# TCP connection

<img src="TCP连接三次握手与四次挥手/image-20210809205222626.png" alt="image-20210809205222626" style="zoom:80%;" />

客户端与服务器之间数据的发送和返回的过程当中需要创建一个叫做`TCP connection`的东西。

由于TCP连接上是可以发送多个`http`请求的，不同的版本模式会存在一些差异。

HTTP/1.0中，TCP连接是在`http`请求创建的时候同步创建的，`http`请求发送到服务器端，服务器端响应之后，这个TCP连接就关闭了；

HTTP/1.1中可以以某种方式声明TCP连接一直保持，一个请求传输完之后，另一个请求可以接着传输；这样的好处是：在创建一个TCP连接的过程中需要“三次握手”的消耗，“三次握手”代表有三次网络传输，在第二次传输的时候就没有“三次握手”的消耗了；

HTTP/2在HTTP/1.1的基础上，可以在同一个TCP连接中并发地传输`http`请求；

# TCP报文

<img src="TCP连接三次握手与四次挥手/image-20210809205921169.png" alt="image-20210809205921169" style="zoom:80%;" />

报文说明：

1. 序号（sequence number）：`Seq`序号，占用32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记；
2. 确认号（acknowledge number）：`Ack`序号，占用32位，只有ACK标志位序号为1时，确认序号字段才有效，`Ack=Seq+1`；
3. 标志位（flags）：供6个，即URG、ACK、PSH、RST、SYN、FIN等；
   1. URG：紧急指针有效；
   2. ACK：确认序号有效；
   3. PSH：接收方应该尽快将报文交给应用层；
   4. RST：重置链接；
   5. SYN：发起一个新的连接；
   6. FIN：释放一个链接；

# TCP连接状态

+ LISTENING

  提供某种服务，侦听远方TCP端口的连接请求，当提供的服务没有被连接时，处于LISTENING状态，端口是开放的，等待被链接；

+ SYN_SENT（客户端状态）

  客户端调用`connect()`，发送一个SYN请求建立一个连接，在发送连接请求后等待匹配的连接请求，此时状态为SYN_SENT;

+ SYN_RECEIVED(服务端状态)

  当收到客户端SYN请求后，服务端会发送一个SYN连接请求及ACK确认到客户端，在等待对方连接请求确认，这时状态为SYN_RCVD，如果有很多SYN_RCVD状态，则可能受到了SYN Flood的Dos攻击；该状态非常短暂；

+ ESTABLISHED

  当客户端回复正确的`Ack`值后，就建立一个打开的连接，客户端和服务器端就都进入ESTABLISHED状态，此时变可以PUSH数据；

+ FIN-WAIT-1

  客户端调用`close()`关闭连接后，TCP发出FIN请求主动关闭连接，然后进入FIN-WAIT-1状态等待远程TCP连接中断请求或者确认；

+ FIN-WAIT-2

  半关闭状态；主动关闭端（也就是客户端调用`close()`后）接收到ACK确认后，此时进入FIN-WAIT-2状态，该状态下，客户端应用程序依然能接收数据；

+ CLOSE-WAIT

  被动关闭状态，TCP接收到FIN后，就发送ACK回应客户端的FIN标识封包；然后进入CLOSE-WAIT状态；

+ CLOSING

  一般为客户端与服务器端同时发起了FIN主动关闭，客户端发送FIN主动关闭，但没有收到服务器端发来的ACK确认，而是先收到了服务端发来的FIN关闭连接，所以必须是同时进入CLOSING状态后，只要收到了对方对自己发送的FIN的ACK，收到FIN的ACK后确认就进入TIME-WAIT状态；因此，如果RTT处在一个可接受的范围内，发出的FIN会很快进入TIME-WAIT状态；所以CLOSING状态持续的时间特别短；

+ LAST-ACK

  服务器端发送确认中断后，也发送FIN关闭，然后进入LAST-ACK最后确认关闭状态；

+ TIME-WAIT

  在主动关闭端接收到FIN后，TCP就发送ACK，并进入TIME-WAIT状态，该状态保持由内核参数默认等待2MSL，之后主动关闭方也进入CLOSED状态关闭连接；

+ CLOSED

  TCP连接关闭，被动关闭端在接收到ACK包后，进入CLOSED状态关闭TCP连接；

# TCP三次握手

## 三次握手详解

<img src="TCP连接三次握手与四次挥手/image-20210809213449864.png" alt="image-20210809213449864" style="zoom:80%;" />

所谓的三次握手即TCP连接的建立过程；这个连接必须是乙方主动打开，另一方被动打开的；

握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段；随后开始“三次握手”：

1. 首先客户端向服务器端发送一段TCP报文，其中：
   1. 标记为为SYN，表示“请求建立新连接”；
   2. 序号为`Seq=X`（X一般为1，对应上图中1000）；
   3. 随后客户端进入SYN-SENT阶段；
2. 服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段，并返回响应报文，其中：
   1. 标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器可正常接收客户端发送的数据，并同意创建新连接”；
   2. 序号为`Seq=Y`（对应上图中2000）；
   3. 确认序号为`Ack=X+1`（对应上图中1001），表示收到客户端的序号`Seq`并将其值加1作为自己的确认号`Ack`的值；随后服务器进入SYN-RCVD阶段；
3. 客户端接收到来自服务器端的确认收到数据的TCP报文后，明确了从客户端到服务器端的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文，其中：
   1. 标志位为ACK，表示“确认收到服务器端同意链接的信号”；（即告知服务器我知道你收到我发送的数据了）
   2. 序号为`Seq=X+1`（上图未标记，对应值为1001），表示收到服务器端的确认号`Ack`，并将其值作为自己的确认号`Ack`的值；
   3. 确认号为`Ack=Y+1`（对应上图中2001）,表示收到服务器端序号`Seq`，并将其值加1作为自己的确认号`Ack`的值；
   4. 客户端进入ESTABLISHED阶段；

服务器端收到来自客户端的“确认收到服务器端数据” 的TCP报文之后，明确了从服务器到客户端的数据传输是正常的；

在客户端与服务器端传输的TCP报文中，双方的确认好`Ack`和序号`Seq`的值，都是在彼此`Ack`和`Seq`值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续“握手”，以此确保“三次握手”的顺利完成；

此后客户端与服务器端进行正常的数据传输，这就是“三次握手”的过程；

## 为什么要进行“三次握手”？

为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务器端，因而产生错误；

由于网络传输是有延时的，在传输的过程中，比如客户端发起了SYN=1的创建连接的请求（第一次握手）；

如果服务器端就直接创建了这个链接并返回包含SYN、ACK和`Seq`等内容的数据包给客户端，这个数据包因为网络传输丢失了，丢失之后客户端一直未再收到服务器端新的数据包；客户端可能设置了一个超时时间，时间到了就关闭了链接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收到了服务器端传输的数据的话，服务器端是不知道客户端是否接收到服务器端返回的信息的；

这样没有给服务器端一个创建还是关闭链接端口的请求，服务器端的端口就一直开放，等到客户端因超时重新发出请求时，服务器端就会重新开启一个端口链接；那么服务器端上没有接收到请求数据的上一个端口就一直开着，长此以往，这样的端口多了，会造成服务器端开销的严重浪费；

还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端认为是有效客户端发出的请求，接收后产生错误；

所以我们需要“三次握手”来确认这个过程，让客户端和服务器端能够及时地察觉到因为网络等问题导致的连接创建失败，这样服务器端的端口就可以关闭而非一直等待；

也可以理解为，“第三次握手”是客户端想服务器端发送数据，这个数据就是要告诉服务器端，客户端有没有收到服务器“第二次握手”时传过去的数据；若发送的数据是“收到”信息，接收后服务器就正常建立TCP连接；否则连接建立失败，服务器关闭链接端口，减少服务器开销和收到失效请求发生的错误；

# TCP四次挥手

<img src="TCP连接三次握手与四次挥手/image-20210809221401054.png" alt="image-20210809221401054" style="zoom:80%;" />

所谓的TCP四次挥手即TCP连接的释放；链接的释放必须必须一方主动释放，另一方被动释放；

以客户端主动发起释放链接为例：

1. 首先客户端想要释放链接，向服务器端发送一段TCP报文，其中：
   1. 标志位为FIN，表示“请求释放连接”；
   2. 序号为`Seq=U`（对应上图中5000）；
   3. 随后客户端进入FIN-WAIT-1阶段，即半关闭阶段；并且停止在客户端到服务器端方向上发送数据，但是客户端仍然等待从服务器端传输过来的数据；（不发送数据是指不发送正常数据，但是仍然可以发送ACK报文数据）；
2. 服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放链接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭阶段）并返回一段TCP报文，其中：
   1. 其中标志位为ACK，表示“接收到客户端发送的释放链接的请求”；
   2. 序号为`Seq=V`（对应上图中7000）；
   3. 确认号为`Ack=U+1`（对应上图中5001），表示是在收到客户端报文的基础上，将其序号`Seq`值加1作为本段报文确认号`Ack`的值；
   4. 随后服务器端开始准备释放服务器端到客户端方向上的连接；客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段；（前两次挥手让服务器端与客户端都知道了对方释放连接的请求；）
3. 服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：
   1. 标志位为FIN、ACK，表示“已准备好释放链接”；
   2. 序号为`Seq=W`（对应上图中7001）；
   3. 确认号为`Ack=U+1`（对应上图中5001）；表示在收到客户端报文的基础上，将其序号`Seq`值加1作为本段报文确认好`Ack`的值；随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段；并且停止在服务器端到客户端的方向上发送数据，但服务器端仍然能够接受从客户端发送过来的数据；
4. 客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放链接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，冰箱服务器端发送一段报文，其中：
   1. 标记为为ACK，表示“接收到服务器准备好释放连接的信号”；
   2. 序号为`Seq=U+1`（对应上图中5001），表示是在收到了服务器端报文的基础上，将其确认号`Ack`值作为本段报文序号的值；
   3. 确认好为`Ack=W+1`（对应上图中7002），表示是在收到了服务器端报文的基础上，将其序号`Seq`值作为本段报文确认号的值；

服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段；由此正式确认关闭服务器端到客户端方向上的连接；

客户端等待完成2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”；与“三次握手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号`Ack`和序号`Seq`的值，都是在彼此的`Ack`和`Seq`值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续“挥手”，以此确保“四次挥手”的顺利完成；

## 为什么“握手”三次，“挥手”需要四次

TCP建立连接时之所以只需要“三次握手”，是因为在第二次“握手”过程中，服务器端发送给客户端的TCP报文是以SYN和ACK作为标志位，SYN是请求连接，表示服务器同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文；

即SYN和ACK确认接收报文是在同一次“握手”当中传输的，所以“三次握手”正好让双方明确彼此信息互通；

TCP释放连接时之所以需要“四次挥手”，是因为FIN释放链接报文与ACK确认接收报文是分别由第二次和第三次“挥手”传输的；为何建立连接可以一起传输，释放连接却要分开传输？

> + 建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK，开始建立连接；
> + 释放连接时，被动方服务器，收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放链接之后，通过第三次“挥手”，返回FIN释放连接报文；

## 为什么客户端在TIME-WAIT阶段要等2MSL

为的是确认服务器端是否接收到客户端发出的ACK确认报文；

当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文；所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器；MSL指的是Maximum  Segment lifetime，即一段TCP报文在传输过程中的最大生命周期；2MSL即服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长；

服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；

> + 如果客户端在2MSL内，**再次**收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有收到客户端发出的ACK确认报文；客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；
>
> + 客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”；

所以客户端要经历时长2MSL的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因；

